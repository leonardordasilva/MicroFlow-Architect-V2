PRD-10 — Correções Pós-Auditoria e Consolidação Técnica
MicroFlow Architect · Product Requirements Document Documento: PRD-10 Arquivo: prd/PRD-10.md Data de criação: 01/03/2026 Status: Aprovado para implementação Prioridade geral: Alta

1. Visão Geral
Este documento especifica os requisitos de melhoria derivados da reanálise técnica pós-implementação do PRD-09, conduzida em março de 2026. A reanálise confirmou que 20 dos 27 itens do PRD-09 foram implementados corretamente, identificou 4 implementações parciais e descobriu 13 novos pontos introduzidos ou expostos pelo código resultante da implementação anterior.

O escopo deste PRD compreende a resolução dos 5 itens remanescentes do PRD-09 (1 não implementado, 4 parciais) e o tratamento dos 13 novos apontamentos identificados, totalizando 18 itens de melhoria.

2. Contexto e Motivação
A implementação do PRD-09 elevou significativamente a maturidade técnica do projeto, com avanços especialmente relevantes na segurança (migração da API Key para Edge Function serverless), na qualidade de código (hook useSaveDiagram, tipagem Supabase, schema Zod) e na cobertura de testes (suite diagramStore). Porém, a reanálise revelou que a migração de arquitetura introduziu novos vetores de risco, e que alguns artefatos legados do scaffolding original ainda residem no repositório, comprometendo a clareza e a segurança da base de código.

3. Objetivos
Os objetivos deste PRD são: eliminar completamente os artefatos legados do scaffolding original que criam confusão e risco de segurança; corrigir vulnerabilidades introduzidas ou expostas pela migração para Edge Functions; garantir cobertura de testes nos módulos ainda descobertos; e resolver os pontos de qualidade, UX e infraestrutura que ficaram pendentes ou incompletos no PRD-09.

4. Itens Fora de Escopo
Os seguintes assuntos não são abordados neste PRD e devem ser tratados separadamente quando aplicável: implementação de autenticação multi-fator, internacionalização da interface para idiomas além do Português do Brasil, e migração da versão do React ou do Vite.

5. Requisitos por Categoria
5.1 Segurança
5.1.1 NEW-SEC-01 — Comentário explicativo na CSP sobre remoção intencional do domínio Google
Problema: Após a migração de SEC-01, o tráfego de IA passou a trafegar por https://ai.gateway.lovable.dev, que já está na CSP. O domínio https://generativelanguage.googleapis.com foi removido corretamente. No entanto, não há nenhum comentário no index.html explicando que essa remoção foi intencional, o que pode levar um desenvolvedor futuro a "corrigir" a CSP reintroduzindo o domínio Google desnecessariamente, ou a gastar tempo depurando chamadas bloqueadas.

Requisito: Adicionar um comentário HTML imediatamente acima da meta tag CSP documentando que o domínio generativelanguage.googleapis.com foi intencionalmente excluído após a migração para o gateway Lovable, e que toda comunicação com IA ocorre via Edge Functions.

Critérios de aceite:

Um comentário HTML <!-- ... --> existe imediatamente acima da meta tag Content-Security-Policy no index.html.
O comentário menciona explicitamente que chamadas à API Gemini são feitas via Edge Functions no servidor e que o domínio Google não deve ser adicionado ao connect-src.
O funcionamento da aplicação não é alterado.
5.1.2 NEW-SEC-02 — Correção da lista de modelos na Edge Function generate-diagram
Problema: O arquivo supabase/functions/generate-diagram/index.ts contém um MODEL_CASCADE com os modelos "google/gemini-3-flash-preview" e "google/gemini-3-pro-preview", que são identificadores inexistentes. Cada requisição de geração de diagrama tenta primeiro esses modelos inválidos antes de chegar aos modelos funcionais, adicionando latência desnecessária e erros nos logs da Edge Function. Este é o mesmo padrão do item QUA-07 (excluído do PRD-09) que foi reintroduzido na Edge Function com nomes de modelo diferentes.

Requisito: Atualizar o array MODEL_CASCADE na Edge Function para conter apenas modelos válidos e disponíveis no gateway Lovable, em ordem de prioridade por custo/capacidade.

Critérios de aceite:

O array MODEL_CASCADE não contém "google/gemini-3-flash-preview" nem "google/gemini-3-pro-preview".
O array contém no mínimo dois modelos válidos disponíveis no gateway https://ai.gateway.lovable.dev.
Após a mudança, uma geração de diagrama bem-sucedida não registra nenhum erro de modelo 404 nos logs da Edge Function.
O fallback entre modelos continua funcional para cenários de rate limit (429) e sobrecarga (503).
5.1.3 NEW-SEC-03 — Rate limiting por usuário nas Edge Functions de IA
Problema: As Edge Functions de geração e análise de diagramas validam o JWT do usuário, mas não limitam quantas vezes um usuário autenticado pode chamar esses endpoints em um dado período. Um usuário com conta válida pode disparar centenas de requisições consecutivas, consumindo créditos da API do gateway sem restrição.

Requisito: Implementar rate limiting baseado em user_id nas Edge Functions de IA. O limite deve ser configurável via variável de ambiente e deve retornar HTTP 429 com mensagem descritiva quando excedido. A contagem deve ser feita via tabela Supabase ou usando a funcionalidade de KV store disponível no ambiente Deno.

Critérios de aceite:

A Edge Function generate-diagram retorna HTTP 429 com corpo { "error": "Limite de requisições atingido. Tente novamente em instantes." } quando o usuário excede o limite configurado.
O limite padrão é de no máximo 10 requisições por minuto por usuário.
O mesmo mecanismo deve ser aplicado à Edge Function analyze-architecture quando esta existir.
Requisições legítimas dentro do limite continuam funcionando normalmente.
O limite é configurável via variável de ambiente AI_RATE_LIMIT_PER_MINUTE sem necessidade de redeploy.
5.1.4 SEC-02 (pendente) — Confirmação da política RLS em saveSharedDiagram
Problema: A função saveSharedDiagram em diagramService.ts executa um UPDATE sem filtro de owner_id. A proteção depende exclusivamente da política RLS do Supabase, mas nenhum arquivo de migration SQL no repositório confirma que essa política está ativa e configurada corretamente. A ausência de evidência no código-fonte é um risco de segurança, pois um deploy em novo ambiente Supabase não teria essa proteção.

Requisito: Criar um arquivo de migration SQL em supabase/migrations/ que defina explicitamente as políticas RLS da tabela diagrams. As políticas devem incluir: SELECT (dono ou share_token válido), INSERT (apenas para o próprio usuário), UPDATE (apenas dono ou colaborador autorizado), DELETE (apenas dono).

Critérios de aceite:

Existe pelo menos um arquivo .sql em supabase/migrations/ contendo as políticas RLS da tabela diagrams.
A política UPDATE permite que auth.uid() = owner_id OU que o usuário esteja em uma lista de colaboradores autorizados.
A política SELECT permite acesso por auth.uid() = owner_id OU por share_token IS NOT NULL (para visualização pública via token).
Um teste manual de tentar fazer UPDATE em um diagrama de outro usuário via Supabase client retorna erro de permissão.
5.2 Qualidade de Código
5.2.1 QUA-01 (pendente) — Remoção do arquivo types.ts legado da raiz
Problema: O arquivo /types.ts na raiz do projeto é um artefato inativo do scaffolding original. Ele importa reactflow (biblioteca legada, não @xyflow/react), define um enum NodeType duplicado em formato incompatível com src/types/diagram.ts, e ainda contém os campos hasDatabase e databaseCount marcados como deprecated — o único item do PRD-09 não implementado. Nenhum arquivo dentro de src/ importa este arquivo, mas sua presença cria confusão e mantém uma dependência inconsistente com o restante da stack.

Requisito: Remover o arquivo /types.ts da raiz do projeto. Confirmar via busca no repositório que nenhum arquivo importa de '../types', './types' (relativo à raiz) ou 'types' sem path qualificado antes da remoção.

Critérios de aceite:

O arquivo /types.ts não existe mais no repositório.
O comando npm run build executa sem erros após a remoção.
O comando npx tsc --noEmit executa sem erros após a remoção.
Nenhum arquivo em src/ importa do caminho relativo que apontaria para o arquivo removido.
5.2.2 NEW-QUA-01 — Remoção do arquivo geminiService.ts legado da raiz
Problema: O arquivo /geminiService.ts na raiz do projeto é o segundo artefato inativo do scaffolding original. Ele contém a lógica legada de chamada direta à API do Google Gemini via process.env.API_KEY no cliente, que foi substituída pelas Edge Functions no PRD-09. A presença deste arquivo cria risco de reimportação acidental, confunde novos contribuidores sobre o fluxo real de integração com IA, e mantém no repositório código que explicitamente expõe uma chave de API no bundle do cliente.

Requisito: Remover o arquivo /geminiService.ts da raiz do projeto. Confirmar que nenhum arquivo ativo o importa antes da remoção.

Critérios de aceite:

O arquivo /geminiService.ts não existe mais no repositório.
O comando npm run build executa sem erros após a remoção.
Nenhum arquivo em src/ importa de '../geminiService' ou './geminiService'.
5.2.3 NEW-QUA-02 — Tipagem correta da instância elkjs em layoutService.ts
Problema: Em layoutService.ts, a instância do ELK é armazenada em let elkInstance: any = null. O uso de any para tipagem da instância elimina a verificação estática de tipos nas chamadas subsequentes ao ELK. Adicionalmente, a variável mutável no escopo de módulo pode ter comportamento inesperado com o HMR do Vite em desenvolvimento, onde o módulo pode ser re-executado sem reinicializar a instância.

Requisito: Substituir any pela tipagem correta importada do pacote elkjs. Adicionar comentário explicando o comportamento esperado em HMR.

Critérios de aceite:

elkInstance tem tipo explícito derivado do pacote elkjs (ex: import type ELK from 'elkjs' e tipo InstanceType<typeof ELK> | null).
Não existe nenhum any no arquivo layoutService.ts.
Um comentário no código explica que elkInstance é um singleton e o comportamento esperado em HMR.
O auto-layout ELK funciona corretamente após a mudança.
5.2.4 NEW-QUA-03 — Substituição de conversões as unknown residuais em diagramService.ts
Problema: Após a refatoração do QUA-02, a função toDiagramRecord em diagramService.ts ainda usa row.nodes as unknown as DiagramNode[] e row.edges as unknown as DiagramEdge[] para converter os campos JSONB retornados pelo Supabase. O schema Zod ImportDiagramSchema já existe em src/schemas/diagramSchema.ts e pode ser reutilizado para fazer essa conversão com segurança em runtime, eliminando as conversões unsafe.

Requisito: Criar um schema Zod derivado de ImportDiagramSchema específico para validação dos dados retornados pelo Supabase (sem o requisito de min(1) nós, já que diagramas vazios podem existir na nuvem). Usar esse schema em toDiagramRecord para substituir as conversões as unknown.

Critérios de aceite:

A função toDiagramRecord não contém nenhuma conversão as unknown.
Os campos nodes e edges são parseados via Zod antes de serem atribuídos ao DiagramRecord.
Caso o parse Zod falhe (dados corrompidos no banco), a função lança um erro descritivo em vez de retornar dados malformados silenciosamente.
O fluxo de save/load de diagramas funciona normalmente após a mudança.
5.3 Correções de Bugs
5.3.1 NEW-QUA-04 — Consumidores de getAutoSave devem usar a versão async
Problema: Após a implementação do PERF-06, a função getAutoSave em useAutoSave.ts foi corretamente convertida para async (necessário pela API DecompressionStream). O componente RecoveryBanner.tsx já foi atualizado e usa .then() corretamente. Porém, é necessário confirmar que não existem outros consumidores que chamem getAutoSave() de forma síncrona, o que retornaria uma Promise não resolvida em vez dos dados, causando bugs silenciosos na lógica de recovery.

Requisito: Realizar uma busca completa por todos os usos de getAutoSave no repositório e garantir que todos os pontos de chamada tratam corretamente o retorno Promise<AutoSaveData | null>. Qualquer consumidor que chame getAutoSave() de forma síncrona deve ser corrigido para usar await ou .then().

Critérios de aceite:

Todos os arquivos que importam getAutoSave usam await getAutoSave() ou getAutoSave().then(...).
O TypeScript emite erro de compilação caso algum consumidor trate o retorno como síncrono (verificado com npx tsc --noEmit).
O fluxo de recovery funciona corretamente em teste manual: criar diagrama, recarregar página, verificar que o banner de recuperação aparece com os dados corretos.
5.3.2 NEW-PERF-01 — Remoção de JSON.stringify duplo em handleRefreshDiagram
Problema: A função handleRefreshDiagram em DiagramCanvas.tsx compara o estado local com os dados remotos usando JSON.stringify(record.nodes) versus JSON.stringify(nodes). Essa operação dupla de serialização é O(n) e ocorre na thread principal quando o usuário clica no botão de refresh. Embora seja uma operação disparada pelo usuário (não automática), a inconsistência com a abordagem adotada em PERF-03 é um antipadrão.

Requisito: Substituir a comparação dupla por JSON.stringify por uma comparação usando o campo record.updated_at. Como o usuário clicou explicitamente no botão de refresh, a lógica pode simplesmente aplicar sempre o estado remoto sem comparação, exibindo uma mensagem diferente caso o diagrama já esteja na versão mais recente com base apenas no timestamp.

Critérios de aceite:

A função handleRefreshDiagram não contém chamadas a JSON.stringify para comparação de estado.
A comparação é feita usando record.updated_at versus um timestamp armazenado localmente, ou o refresh é aplicado diretamente.
O comportamento do usuário permanece idêntico: se já está atualizado, exibe toast "Diagrama já está atualizado."; caso contrário, aplica e exibe "Diagrama atualizado com sucesso!".
5.4 Testes
5.4.1 INF-03 (pendente, parte 1) — Testes unitários para geminiService (parser JSON)
Problema: O arquivo src/services/geminiService.test.ts não foi criado, conforme identificado na reanálise. A função extractJSON — que faz parsing robusto de respostas mistas da IA — é um dos pontos mais críticos para a estabilidade da geração de diagramas e permanece sem cobertura de testes.

Nota importante: Com a migração para Edge Functions (SEC-01), o geminiService.ts em src/ pode ter sido refatorado ou removido. Caso a lógica de extractJSON tenha sido movida para a Edge Function ou para um utilitário compartilhado, os testes devem cobrir onde essa lógica efetivamente reside.

Requisito: Criar testes unitários que cubram a lógica de extração e parsing de JSON das respostas da IA, independentemente de onde essa lógica esteja localizada após a migração.

Critérios de aceite:

Existe um arquivo de teste cobrindo a função de extração/parsing de JSON da IA.
Os seguintes cenários são testados: JSON puro válido, JSON embutido em texto com markdown (```json ... ```), JSON embutido em texto sem markdown, string sem JSON válido (deve retornar null ou lançar erro), JSON com arrays (não apenas objetos), e JSON com trailing content após o fechamento.
O comando npm test executa todos os novos testes com sucesso.
5.4.2 INF-03 (pendente, parte 2) — Testes de contrato para diagramService
Problema: O arquivo src/services/diagramService.test.ts não foi criado. As funções de persistência do Supabase não possuem testes com mocks, o que significa que bugs de regressão nas operações de save/load só são detectados em produção.

Requisito: Criar testes de contrato para diagramService.ts usando mocks do cliente Supabase. Os testes devem verificar o comportamento das funções em cenários de sucesso e de erro, sem fazer chamadas reais ao banco de dados.

Critérios de aceite:

O arquivo src/services/diagramService.test.ts existe.
As seguintes funções têm pelo menos um teste de caminho feliz e um teste de caminho de erro: saveDiagram (novo e update), loadDiagramById, deleteDiagram, e renameDiagram.
O mock do Supabase é implementado corretamente via vi.mock() do Vitest.
renameDiagram tem testes específicos para validação do título (vazio, muito longo, válido).
O comando npm test executa todos os novos testes com sucesso.
5.5 UX e Acessibilidade
5.5.1 NEW-UX-01 — type="button" explícito em todos os elementos <button> da página de Auth
Problema: Em Auth.tsx, os botões de navegação entre views ("Esqueceu sua senha?", "Criar conta", "Fazer login", "Voltar ao login") já possuem type="button", o que está correto. Porém, durante a revisão, identificou-se que o padrão de usar <button> sem classe ou componente de UI padronizado (fora do design system Radix/Shadcn) para links de navegação cria inconsistência visual e semântica. Elementos que funcionam como links de navegação interna devem usar comportamento e aparência de link.

Requisito: Substituir os elementos <button type="button"> usados como links de navegação entre views em Auth.tsx por um padrão consistente com o design system. Manter type="button" explícito em todos os elementos <button> que não são submit, garantindo que o formulário nunca seja submetido acidentalmente.

Critérios de aceite:

Todos os <button> em Auth.tsx que não são de submit têm type="button" explícito.
O comportamento de navegação entre as views (login, signup, forgot) funciona corretamente.
Não há regressão no fluxo de autenticação (login, cadastro, recuperação de senha).
5.5.2 NEW-UX-02 — Atributo autoComplete nos campos do formulário de autenticação
Problema: Os campos de email e password em Auth.tsx não definem o atributo autoComplete. Isso impede que gerenciadores de senha e o preenchimento automático do navegador funcionem corretamente, prejudicando a experiência do usuário e potencialmente reduzindo a adoção de senhas fortes.

Requisito: Adicionar o atributo autoComplete apropriado a cada campo de input do formulário de autenticação, variando conforme o contexto (login vs. cadastro).

Critérios de aceite:

O campo de email tem autoComplete="email" em todas as views.
O campo de senha no login tem autoComplete="current-password".
O campo de senha no cadastro tem autoComplete="new-password".
O preenchimento automático do navegador funciona corretamente para o fluxo de login.
5.6 Infraestrutura e Documentação
5.6.1 NEW-INF-01 — Documentação das variáveis de ambiente das Edge Functions
Problema: O arquivo .env.example criado no INF-01 documenta apenas as variáveis do cliente (VITE_SUPABASE_URL, VITE_SUPABASE_PUBLISHABLE_KEY, VITE_SUPABASE_PROJECT_ID). Com a implementação das Edge Functions em SEC-01, existem variáveis de ambiente de servidor (LOVABLE_API_KEY, ALLOWED_ORIGINS, SUPABASE_URL, SUPABASE_ANON_KEY, AI_RATE_LIMIT_PER_MINUTE) que precisam ser configuradas no painel do Supabase e não estão documentadas em nenhum lugar do repositório. Novos deployments em ambientes limpos falharão silenciosamente sem essa documentação.

Requisito: Criar o arquivo supabase/functions/.env.example documentando todas as variáveis de ambiente necessárias para as Edge Functions, com descrição de cada variável e onde obtê-la. Atualizar o README.md (ou criar um se não existir) referenciando ambos os arquivos .env.example.

Critérios de aceite:

O arquivo supabase/functions/.env.example existe com as seguintes variáveis documentadas: LOVABLE_API_KEY, ALLOWED_ORIGINS, SUPABASE_URL, SUPABASE_ANON_KEY, e AI_RATE_LIMIT_PER_MINUTE.
Cada variável tem um comentário explicando sua finalidade, formato esperado e onde obtê-la.
O README.md (existente ou criado) menciona a necessidade de configurar variáveis de ambiente tanto no .env.local quanto no painel do Supabase para as Edge Functions.
6. Requisitos Não-Funcionais
Os seguintes requisitos se aplicam a todas as implementações deste PRD. Toda mudança de código deve compilar sem erros TypeScript em modo strict com npx tsc --noEmit. Nenhuma das mudanças pode introduzir regressões nas funcionalidades existentes de criação, edição, geração por IA, save/load, exportação e colaboração em tempo real. Novos testes unitários devem atingir 100% de aprovação no comando npm test. O bundle de produção gerado por npm run build não deve aumentar em mais de 5KB (gzip) em relação ao baseline do PRD-09. Remoções de arquivos devem ser validadas com busca de imports antes da execução.

7. Ordem de Implementação e Dependências
A implementação deve respeitar a seguinte ordem para minimizar riscos. A remoção dos artefatos legados (QUA-01, NEW-QUA-01) deve ser feita primeiro, pois elimina código morto que poderia confundir as demais análises. A seguir, o item SEC-02 (pendente) deve ser implementado antes dos itens NEW-SEC-03 e NEW-QUA-03, pois todos envolvem a camada de dados do Supabase e é mais seguro ter as políticas RLS confirmadas antes de fazer mudanças adicionais. Os testes (INF-03 partes 1 e 2) devem ser implementados após todas as mudanças de código dos itens de qualidade, para que reflitam o estado final. Os demais itens são independentes entre si e podem ser implementados em paralelo.

8. Critérios de Conclusão do PRD
O PRD-10 será considerado concluído quando todos os 18 itens tiverem seus critérios de aceite verificados e aprovados; o comando npm run build executar sem erros ou warnings; o comando npm test executar com todos os testes passando; nenhum arquivo de artefato legado (/types.ts, /geminiService.ts) existir no repositório; e nenhuma regressão funcional for identificada nos fluxos principais da aplicação.