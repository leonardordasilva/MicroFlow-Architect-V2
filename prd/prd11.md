# PRD-11 — Refinamentos Pós-Auditoria Ciclo 3

**Projeto:** MicroFlow Architect  
**Documento:** PRD-11  
**Data:** 01/03/2026  
**Status:** Aprovado  
**Prioridade:** Média  
**Autor:** Auditoria Técnica Automatizada  
**Versão:** 1.0  

---

## 1. Contexto e Objetivo

Este documento registra os apontamentos identificados na terceira
rodada de auditoria técnica do repositório MicroFlow-Architect, 
realizada em 01/03/2026. As auditorias anteriores (PRD-09 e PRD-10)
resolveram 43 itens críticos e de alta prioridade relacionados à
segurança da API Key, validação de entradas, Row Level Security,
Content-Security-Policy, auto-save com compressão, rate limiting
e cobertura de testes. Os 9 pontos remanescentes são de criticidade
média a alta, sem risco crítico imediato para produção, mas com
impacto direto em estabilidade, manutenibilidade e performance.

O objetivo deste PRD é detalhar cada apontamento com contexto,
critério de aceite mensurável e ordem de execução recomendada,
de forma que o desenvolvedor (ou agente Lovable) possa implementar
as correções de modo incremental e rastreável.

---

## 2. Resumo dos Apontamentos

| ID      | Título resumido                                    | Criticidade | Categoria       |
|---------|----------------------------------------------------|-------------|-----------------|
| A01     | loadUserDiagrams sem tratamento de erro por item   | Alta        | Segurança/Bug   |
| A02     | Tabela ai_requests sem política de limpeza         | Alta        | Segurança/Infra |
| A03     | any residual em layoutService (find callback)      | Média       | Qualidade       |
| A04     | Casts as DiagramNode[]/DiagramEdge[] pós safeParse | Média       | Qualidade       |
| A05     | Double cast as unknown as DiagramNodeData          | Média       | Qualidade       |
| A06     | Concatenação O(n²) em compressString               | Média       | Performance     |
| A07     | Teste happy-path ausente em loadDiagramById        | Média       | Testes          |
| A08     | Bloco if vazio morto em useRealtimeCollab          | Baixa       | Qualidade       |
| A09     | Constante TRACKED_KEYS não utilizada               | Baixa       | Qualidade       |

---

## 3. Detalhamento dos Apontamentos

### 3.1 A01 — loadUserDiagrams sem tratamento de erro por item

**Arquivo afetado:** `src/services/diagramService.ts`  
**Função afetada:** `loadUserDiagrams`

**Situação atual:**
A função `loadUserDiagrams` busca a lista de diagramas do usuário
autenticado e, para cada linha retornada pelo Supabase, chama
`toDiagramRecord(row)`. A função `toDiagramRecord` realiza validação
Zod e lança um erro em português caso os dados estejam corrompidos.
Se qualquer diagrama do usuário tiver dados inválidos, o erro
propagado vai estourar o `Promise.all` implícito do mapeamento,
resultando em tela em branco ou crash na página `/my-diagrams`, sem
capacidade de recuperação para os outros diagramas válidos.

**Impacto:** Qualquer diagrama persistido com schema antigo ou com
dados parcialmente corrompidos derruba toda a listagem do usuário.

**Correção esperada:**
Envolver a chamada a `toDiagramRecord` em um `try/catch` por item,
descartando silenciosamente (ou logando) os diagramas que falharem
na validação e retornando apenas os válidos. Alternativamente,
usar `flatMap` com lógica de recuperação.

Exemplo de implementação:

```typescript
const diagrams = (data ?? []).flatMap((row) => {
  try {
    return [toDiagramRecord(row)];
  } catch (err) {
    console.warn(`Diagrama ${row.id} ignorado por dados corrompidos:`, err);
    return [];
  }
});
Copy
Critério de aceite:

Um diagrama com nodes corrompido na base não impede a exibição dos demais.
A função loadUserDiagrams nunca lança para o chamador em razão de dados inválidos em um item individual.
Um console.warn identificando o diagrama corrompido é emitido.
3.2 A02 — Tabela ai_requests sem política de limpeza
Arquivo afetado: supabase/functions/generate-diagram/index.ts e schema da tabela ai_requests (migrations).

Situação atual: O rate limiting implementado no PRD-10 utiliza uma tabela ai_requests que registra cada requisição de geração de diagrama por usuário. A contagem usa uma janela de 1 minuto, mas as linhas antigas nunca são removidas, resultando em crescimento ilimitado da tabela. Em uso contínuo, isso gera degradação de performance nas queries de contagem e aumento de custos no Supabase.

Impacto: Crescimento linear e irrestrito de registros; queries de rate-check ficam progressivamente mais lentas; possível impacto em faturamento do plano Supabase.

Correção esperada (duas frentes complementares):

Frente 1 — Limpeza pró-ativa na própria Edge Function: Antes ou após a inserção do novo registro de rate-limit, executar um DELETE que remove registros com mais de 5 minutos:

CopyDELETE FROM ai_requests
WHERE user_id = $1
  AND created_at < NOW() - INTERVAL '5 minutes';
Frente 2 — Migration com índice e política de retenção: Criar uma migration que adicione:

Índice composto em (user_id, created_at) para performance nas queries de contagem.
Comentário na tabela documentando a política de retenção esperada (5 minutos de janela ativa).
Critério de aceite:

Após 100 requisições simuladas espaçadas no tempo, a tabela ai_requests não acumula mais do que registros dos últimos 5 minutos para um dado usuário.
A query de contagem para rate-check executa em menos de 5 ms (verificável via EXPLAIN ANALYZE no Supabase Dashboard).
Existe migration com o índice idx_ai_requests_user_created.
3.3 A03 — any residual em layoutService (find callback)
Arquivo afetado: src/services/layoutService.ts
Função afetada: getELKLayoutedElements

Situação atual: No callback find usado para mapear os resultados do layout ELK de volta aos nós React Flow, o parâmetro do callback está tipado implicitamente como any. Embora o PRD-10 tenha corrigido a tipagem do singleton elkInstance, este callback residual mantém uma lacuna de type-safety.

Código afetado (aproximação):

Copy// antes
const layoutedNode = elkGraph.children?.find((n: any) => n.id === node.id);

// depois
const layoutedNode = elkGraph.children?.find(
  (n: ElkNode) => n.id === node.id
);
Impacto: Baixo risco de bug em produção, mas viola o contrato de tipagem do projeto e pode mascarar erros de estrutura da resposta ELK em versões futuras da biblioteca.

Critério de aceite:

O arquivo layoutService.ts não contém nenhuma ocorrência de : any após a correção.
O build TypeScript (tsc --noEmit) continua passando sem erros.
3.4 A04 — Casts inseguros as DiagramNode[]/DiagramEdge[] após safeParse
Arquivo afetado: src/services/diagramService.ts
Função afetada: toDiagramRecord e possivelmente loadDiagram em diagramStore.ts.

Situação atual: Após validar dados com ImportDiagramSchema.safeParse ou schemas derivados, o código ainda usa casts explícitos as DiagramNode[] e as DiagramEdge[]. Esses casts silenciam erros de TypeScript caso os tipos inferidos pelos schemas Zod não sejam estruturalmente compatíveis com as interfaces manuais DiagramNode e DiagramEdge. O resultado correto seria fazer o TypeScript inferir automaticamente os tipos a partir do schema.

Correção esperada: Usar o tipo inferido pelo Zod (z.infer<typeof NodeSchema>[]) ou garantir que DiagramNode e DiagramEdge sejam definidos como z.infer<typeof NodeSchema> no arquivo src/types/diagram.ts, eliminando a duplicação de contratos.

Critério de aceite:

Nenhuma ocorrência de as DiagramNode[] ou as DiagramEdge[] no código-fonte.
O TypeScript infere os tipos corretamente via Zod sem casts.
tsc --noEmit passa sem erros.
3.5 A05 — Double cast as unknown as DiagramNodeData
Arquivo afetado: src/store/diagramStore.ts

Situação atual: Em pelo menos um ponto do store Zustand existe o padrão node.data as unknown as DiagramNodeData. Este double cast (primeiro para unknown, depois para o tipo desejado) é um anti-padrão TypeScript que indica que os tipos divergem e o compilador foi forçado a silenciar o erro. Na prática, pode mascarar incompatibilidades reais entre o dado armazenado e a interface esperada pelos componentes.

Correção esperada: Revisar o ponto onde o cast ocorre e garantir que o tipo de node.data seja declarado corretamente desde a origem (no addNode, no loadDiagram ou no tipo genérico do ReactFlow). Se a tipagem de @xyflow/react exige um cast, documentar o motivo com um comentário // @ts-expect-error com justificativa, que é semanticamente mais honesto que um double cast.

Critério de aceite:

Nenhuma ocorrência de as unknown as no arquivo diagramStore.ts.
O build continua passando sem erros ou supressões não documentadas.
3.6 A06 — Concatenação O(n²) em compressString (useAutoSave)
Arquivo afetado: src/hooks/useAutoSave.ts
Função afetada: compressString

Situação atual: A função compressString lê os chunks do CompressionStream e os converte para string usando concatenação em loop do tipo result += String.fromCharCode(...chunk). Concatenação de strings em loop em JavaScript cria uma nova string a cada iteração, resultando em alocações O(n²) em memória para diagramas grandes (muitos nós/arestas). Em diagramas com dezenas de nós e arestas, isso pode causar janela de congelamento perceptível ao salvar.

Correção esperada: Coletar todos os Uint8Array chunks em um array e converter somente ao final, ou usar TextDecoder com Uint8Array concatenado:

Copyconst chunks: Uint8Array[] = [];
// ... leitura do stream ...
chunks.push(chunk);
// ao final:
const merged = new Uint8Array(chunks.reduce((acc, c) => acc + c.length, 0));
let offset = 0;
for (const c of chunks) { merged.set(c, offset); offset += c.length; }
const base64 = btoa(String.fromCharCode(...merged));
Ou, mais idiomaticamente, usar Blob + arrayBuffer:

Copyconst blob = await new Response(compressed).blob();
const buffer = await blob.arrayBuffer();
const base64 = btoa(
  String.fromCharCode(...new Uint8Array(buffer))
);
Critério de aceite:

Função compressString não usa concatenação iterativa de strings.
Auto-save de um diagrama com 50 nós e 60 arestas completa em menos de 100 ms (verificável via console.time).
Os testes existentes de auto-save continuam passando.
3.7 A07 — Teste happy-path ausente em loadDiagramById
Arquivo afetado: src/services/diagramService.test.ts

Situação atual: A suíte de testes de diagramService cobre o caminho de erro de loadDiagramById (retorna null quando o Supabase retorna erro), mas não cobre o caminho feliz: quando o Supabase retorna um registro válido, a função deve parsear os dados via toDiagramRecord e retornar um DiagramRecord populado corretamente.

Impacto: A ausência do teste happy-path significa que uma regressão em toDiagramRecord ou em loadDiagramById não seria capturada pelo CI.

Correção esperada: Adicionar um caso de teste que:

Configure o mock do Supabase para retornar mockRow sem erro.
Chame loadDiagramById('diag-1').
Verifique que o resultado não é null e contém id, title, nodes e edges válidos conforme o mockRow.
Critério de aceite:

O arquivo diagramService.test.ts contém pelo menos 1 teste de caminho feliz para loadDiagramById.
npm test executa todos os testes sem falhas.
Cobertura de diagramService.ts atinge ≥ 80%.
3.8 A08 — Bloco if vazio morto em useRealtimeCollab
Arquivo afetado: src/hooks/useRealtimeCollab.ts

Situação atual: Existe pelo menos um bloco if (condição) { } com corpo vazio, remanescente de uma refatoração anterior. Este tipo de código morto aumenta a complexidade cognitiva e pode confundir futuras leituras de código, sugerindo que algum comportamento foi intencionalmente omitido.

Correção esperada: Remover o bloco vazio. Se a lógica foi intencionalmente adiada, substituir por um comentário // TODO: <descrição> ou abrir issue rastreável.

Critério de aceite:

Nenhum bloco if com corpo vazio em useRealtimeCollab.ts.
npm run lint passa sem avisos no arquivo.
3.9 A09 — Constante TRACKED_KEYS não utilizada
Arquivo afetado: src/store/diagramStore.ts

Situação atual: A constante TRACKED_KEYS foi declarada mas não é referenciada em nenhum ponto do código. É provável que tenha sido criada durante a implementação do undo/redo parcial e depois substituída por outra abordagem. Constantes não utilizadas geram confusão sobre a intenção do código e ativam avisos de lint.

Correção esperada: Remover a declaração de TRACKED_KEYS. Se o valor tiver relevância futura, mover para um arquivo de documentação ou comentário.

Critério de aceite:

Nenhuma declaração de TRACKED_KEYS em diagramStore.ts.
npm run lint passa sem avisos no arquivo.
npm test continua passando sem modificações nos testes.
4. Ordem de Execução Recomendada
A implementação deve seguir a ordem abaixo para minimizar dependências entre alterações e garantir que os testes possam validar cada fase incrementalmente.

Fase 1 — Alta prioridade (estabilidade em produção): Implementar A01 e A02. Esses dois itens têm impacto direto na experiência do usuário final (crash na listagem) e em custos de infraestrutura (crescimento de tabela).

Fase 2 — Qualidade de tipagem (segurança em desenvolvimento): Implementar A03, A04 e A05 em sequência, pois todos estão relacionados à eliminação de any e casts inseguros. Após cada correção, rodar tsc --noEmit para garantir que o build TypeScript não quebrou.

Fase 3 — Performance: Implementar A06 de forma isolada. Testar manualmente com um diagrama de 50+ nós antes de marcar como concluído.

Fase 4 — Testes e limpeza: Implementar A07 (adicionar teste), A08 (remover if vazio) e A09 (remover constante). Finalizar com npm test completo para confirmar cobertura.

5. Critérios de Aceite Globais
Ao finalizar todas as fases, o repositório deve satisfazer simultaneamente:

npm run build conclui sem erros ou warnings de TypeScript.
npm test executa 100% dos testes sem falhas, com cobertura ≥ 80% nos arquivos diagramService.ts, diagramStore.ts e useAutoSave.ts.
npm run lint retorna zero warnings nos arquivos modificados.
A página /my-diagrams renderiza corretamente mesmo que um diagrama na base esteja com dados corrompidos.
A tabela ai_requests não ultrapassa 1.000 linhas após 24 horas de uso normal.
tsc --noEmit não contém nenhuma ocorrência de as unknown as ou : any nos arquivos modificados.
6. Fora do Escopo deste PRD
Os seguintes itens estão explicitamente excluídos deste documento:

Qualquer alteração no fluxo de autenticação.
Mudanças no esquema de nodes/edges ou nos tipos de nó.
Novos recursos de UI ou alterações visuais.
Migração de provedor de AI ou mudanças no prompt da Edge Function.
Implantação de pipeline CI/CD (endereçado separadamente).